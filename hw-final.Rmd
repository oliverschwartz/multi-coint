---
title: "Multidimensional Cointegration"
author: "Oliver Schwartz"
date: "4/28/2021"
output: html_document
---

```{r setup, include=FALSE}
# Setup.
knitr::opts_chunk$set(echo = TRUE)
setwd("~/workspace/classes/multi-coint") # Dan TODO: change this dir. 

# Imports. 
library(rkdb)
library(digest)
```


```{r include=FALSE}
rm(list=ls())

# Set cache dir. 
CACHE <- "./cache"
dir.create(CACHE, showWarnings=FALSE)
hfm <- open_connection("hfm", 2015)

# Caches and retries query. Relies on global hfm variable and CACHE
try_execute <- function(x) {
  retriesLeft = 5
  cacheName = sprintf("%s/%s.RDS", CACHE, digest::digest(x, algo="md5", 
                                                         serialize=FALSE))
  if (file.exists(cacheName)) {
    return(readRDS(cacheName))
  }

  tmp = try(execute(hfm, x), silent=TRUE)
  
  # Retry some number of times. 
  while (class(tmp) == "try-error" && retriesLeft > 0) {
    retriesLeft = retriesLeft - 1;
    port = 6000 + sample.int(9, 1) # try a random port
    print(paste("[INFO] Sleeping 5 seconds and reconnecting... to port:", port))
    Sys.sleep(5)
    hfm = try(open_connection('hfm.princeton.edu', port), silent=TRUE)
    if (class(hfm) != "try-error") { # Only try again if connection worked
      tmp = try(execute(hfm, x), silent=TRUE)
    }
  }
  
  # Too many retries. 
  if (class(tmp) == "try-error") {
    print("Failed maximum number of retries. Quitting")
    return()
  }

  # Save to cache.
  saveRDS(tmp, file=cacheName)
  tmp
}
```

First, we will choose a set of 8 closely related products. We will use Eurodollars maturing March 2021 through to December 2022 - i.e. `GEH1, GEM1, GEU1, GEZ1, GEM2, GEU2, GEZ2`. 

We sample the quote midpoint prices at 1-minute intervals for the entire 23-hour trading day, for any day in October 2020 (our data set). 
```{r}
# Constants. 
SYMS <- c("GEH1", "GEM1", "GEU1", "GEZ1", "GEM2", "GEU2", "GEZ2")
DATE <- "2020.10.05"
NSEC <- 23 * 3600
TMIN <- "-0D07:00:00"

# Get midpoint data for all symbols. 
mid_by_sym <- list()
for (sym in SYMS) {
  q1 <- sprintf("([] time:%s+1000000000 * til %d)", TMIN, NSEC)
  q2 <- sprintf(
    "select time, mid:0.5*(bid+ask) from quote where sym=`%s, date=%s",
    sym, DATE
  )
  q3 <- sprintf("aj[`time; %s; %s]", q1, q2)
  mid_by_sym[[sym]] <- try_execute(q3)
}
```

Let's plot `GEH1` and `GEZ1` to visualize the price relationship. 
```{r}
plot(mid_by_sym[["GEH1"]]$mid, mid_by_sym[["GEZ1"]]$mid, type="o",
     main=sprintf("GEH1/GEZ1 on %s", DATE), ylab="GEZ1", xlab="GEH1")
grid()
```

Our assumption is that all 8 prices move back and forth along a 1-dimensional line. (We will all take more degrees of freedom, for instance, we might assume the prices move along a 2d-plane in $\mathbb{R}^8$.)

We need to compute exponential rolling averages using a 1-hour window time. How do we compute an exponential rolling average? At a time $n$, the exponential average is given by $A_n / B_n$ where:
$$
\begin{align*}
A_n &= \sum_{j=1}^n e^{-(n-j) / m} x_j \\
B_n &= \sum_{j=1}^n e^{-(n-j) / m} 
\end{align*}
$$
This yields the following recursive update rules, which makes this computation constant at every time step, i.e. O(1).
$$
\begin{align*}
A_n &= e^{-(n-j) / m} x_j = x_n + \sum_{j=1}^{n-1}e^{-(n-j) / m} x_j \\
&= x_n + e^{-1/m} \cdot \sum_{j=1}^{n-1}e^{-(n-j-1) / m} x_j \\
&= x_n + e^{-1/m} \cdot A_{n-1}
\end{align*}
$$
Similarly, for $B_n$: 
$$
B_n = 1 + e^{-1/m}\cdot B_{n-1}
$$

```{r}

# Compute the rolling statistics for a time series.
# Returns a list with:
# - ema: exponentially weighted average for given window size.
# - std: rectangular standard deviation for given window size. 
rolling_stats <- function(x, y, wlen) {
  
  # Initialize values to compute exp mean, exp std. 
  N <- length(x)
  ema <- c(x[1])    # Exponential average. 
  mean <- c(x[1])   # Rectangular mean (for below two quantities). 
  sqr <- c(x[1]**2) # Rectangular mean of squared prices. 
  std <- c(0)       # Rectangular standard deviation. 
  
  # For ema calculation.  
  A <- x[1]
  B <- 1
  
  for (t in 2:N) {
    A <- x[t] + exp(-1 / wlen) * A
    B <- 1 + exp(-1 / wlen) * B
    ema[t] <- A / B
    
    # If we have seen a window's worth of data. 
    if (t > wlen) {
      mean[t] <- (x[t] + wlen*mean[t-1] - x[t-wlen]) / wlen
      sqr[t] <- (x[t]**2 + wlen*sqr[t-1] - x[t-wlen]**2) / wlen
    } 
    
    # We haven't seen a window's worth of data (only t-1 prior values). 
    else { 
      mean[t] <- (x[t] + (t-1)*mean[t-1]) / t
      sqr[t] <- (x[t]**2 + (t-1)*sqr[t-1]) / t
    }
    std[t] <- sqrt(sqr[t] - mean[t]**2)
  }

  return(list(ema=ema,std=std))
}
```

```{r}
for (sym in SYMS[1]) {
  mid_by_sym[[sym]]$ema <- exp_ma(mid_by_sym[[sym]]$mid, wlen=3600)
}
```



At each point in time, we compute the SVD of the covariance matrix. We compute a forecast price $P_*$, the projection of the actual price $P$ onto the first principal component of the covariance matrix.



















