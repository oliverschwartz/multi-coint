---
title: "Multidimensional Cointegration"
author: "Oliver Schwartz"
date: "4/28/2021"
output: html_document
---

```{r setup, include=FALSE}
# Setup.
knitr::opts_chunk$set(echo = TRUE)
setwd("~/workspace/classes/multi-coint") # Dan TODO: change this dir. 

# Imports. 
library(rkdb)
library(digest)
```


```{r include=FALSE}
rm(list=ls())

# Set cache dir. 
CACHE <- "./cache"
dir.create(CACHE, showWarnings=FALSE)
hfm <- open_connection("hfm", 2015)

# Caches and retries query. Relies on global hfm variable and CACHE
try_execute <- function(x) {
  retriesLeft = 5
  cacheName = sprintf("%s/%s.RDS", CACHE, digest::digest(x, algo="md5", 
                                                         serialize=FALSE))
  if (file.exists(cacheName)) {
    return(readRDS(cacheName))
  }

  tmp = try(execute(hfm, x), silent=TRUE)
  
  # Retry some number of times. 
  while (class(tmp) == "try-error" && retriesLeft > 0) {
    retriesLeft = retriesLeft - 1;
    port = 6000 + sample.int(9, 1) # try a random port
    print(paste("[INFO] Sleeping 5 seconds and reconnecting... to port:", port))
    Sys.sleep(5)
    hfm = try(open_connection('hfm.princeton.edu', port), silent=TRUE)
    if (class(hfm) != "try-error") { # Only try again if connection worked
      tmp = try(execute(hfm, x), silent=TRUE)
    }
  }
  
  # Too many retries. 
  if (class(tmp) == "try-error") {
    print("Failed maximum number of retries. Quitting")
    return()
  }

  # Save to cache.
  saveRDS(tmp, file=cacheName)
  tmp
}
```

## Getting data

First, we will choose a set of 8 closely related products. We will use Eurodollars maturing March 2021 through to December 2022 - i.e. `GEH1, GEM1, GEU1, GEZ1, GEM2, GEU2, GEZ2`. 

We sample the quote midpoint prices at 1-minute intervals for the entire 23-hour trading day, for any day in October 2020 (our data set). 
```{r}
# Constants. 
SYMS <- c("GEH1", "GEM1", "GEU1", "GEZ1", "GEH2", "GEM2", "GEU2", "GEZ2")
DATE <- "2020.10.05"
NSEC <- 23 * 3600
TMIN <- "-0D07:00:00"

# Get midpoint data for all symbols. 
mid_by_sym <- list()
for (sym in SYMS) {
  q1 <- sprintf("([] time:%s+1000000000 * til %d)", TMIN, NSEC)
  q2 <- sprintf(
    "select time, mid:0.5*(bid+ask) from quote where sym=`%s, date=%s",
    sym, DATE
  )
  q3 <- sprintf("aj[`time; %s; %s]", q1, q2)
  mid_by_sym[[sym]] <- try_execute(q3)
}
```

Let's plot `GEH1` and `GEZ1` to visualize the price relationship. Eurodollars are a large tick asset (with deep order books) so we might expect very minimal price fluctuations. 
```{r}
plot(mid_by_sym[["GEH1"]]$mid, mid_by_sym[["GEZ1"]]$mid, type="o",
     main=sprintf("GEH1/GEZ1 on %s", DATE), xlab="GEH1", ylab="GEZ1")
grid()
```

## Rolling statistics

Our assumption is that all 8 prices move back and forth along a 1-dimensional line. (We will all take more degrees of freedom, for instance, we might assume the prices move along a 2d-plane in $\mathbb{R}^8$.)

We need to compute exponential rolling averages using a 1-hour window time. 

How do we compute an exponential rolling average? At a time $n$, the exponential average is given by $A_n / B_n$ where:
$$
\begin{align*}
A_n &= \sum_{j=1}^n e^{-(n-j) / m} x_j \\
B_n &= \sum_{j=1}^n e^{-(n-j) / m} 
\end{align*}
$$

This yields the following recursive update rules, which makes this computation constant at every time step, i.e. O(1).
$$
\begin{align*}
A_n &= e^{-(n-j) / m} x_j = x_n + \sum_{j=1}^{n-1}e^{-(n-j) / m} x_j \\
&= x_n + e^{-1/m} \cdot \sum_{j=1}^{n-1}e^{-(n-j-1) / m} x_j \\
&= x_n + e^{-1/m} \cdot A_{n-1}
\end{align*}
$$
Similarly, for $B_n$: 
$$
B_n = 1 + e^{-1/m}\cdot B_{n-1}
$$

```{r}

# Compute the rolling statistics for two time series.
# Returns a list with:
# - ema: exponentially weighted average for given window size.
# - std: rectangular standard deviation for given window size. 
rolling_stats <- function(x, y, wlen) {
  
  # Initialize values to compute exp mean, exp std. 
  N <- length(x)
  ema_x <- c(x[1])      # Exponential average. 
  ema_y <- c(y[1])    
  sqr_x <- c(x[1]**2)   # Rectangular mean of squared prices. 
  sqr_y <- c(x[1]**2) 
  std_x <- c(0)         # Rectangular standard deviation. 
  std_y <- c(0)
  
  # For ema calculation.  
  A_x <- x[1]
  A_y <- y[1]
  B_x <- 1
  B_y <- 1
  
  for (t in 2:N) {
    
    # Tracking. 
    if (TRUE) {
      print(t)
      print(std_x)
      print(std_y)
      print("")
    }
    
    # EMA updates. 
    A_x <- x[t] + exp(-1 / wlen) * A_x
    A_y <- y[t] + exp(-1 / wlen) * A_y
    B_x <- 1 + exp(-1 / wlen) * B_x
    B_y <- 1 + exp(-1 / wlen) * B_y
    ema_x[t] <- A_x / B_x
    ema_y[t] <- A_y / B_y
    
    # If we have seen a window's worth of data. 
    if (t > wlen) {
      sqr_x[t] <- sqr_x[t] + (x[t]**2 - x[t-wlen]**2) / wlen
      sqr_y[t] <- sqr_y[t] + (y[t]**2 - y[t-wlen]**2) / wlen
    }
    else { # We haven't seen a window's worth of data. 
      sqr_x[t] <- (x[t]**2 + (t-1)*sqr_x[t-1]) / t
      sqr_y[t] <- (y[t]**2 + (t-1)*sqr_y[t-1]) / t
    }
    
    # Compute standard deviation and correlation. 
    browser()
    # std_x[t] <- sqrt(sqr_x[t] - ema_x[t]**2)
    # std_y[t] <- sqrt(sqr_y[t] - ema_y[t]**2)
  }

  return(list(
    ema_x=ema_x, 
    ema_y=ema_y, 
    std_x=std_x,
    std_y=std_y
  ))
}

rolling_stats(x, y, wlen=3)
```

For every unique pair of instruments, compute their rolling statistics and their rolling correlation. 
```{r}
pairwise_stats <- list()
WINDOW_LEN <- 3600

for (i in 1:(length(SYMS)-1)) {
  for (j in (i+1):length(SYMS)) {
    key <- paste0(SYMS[i], ",", SYMS[j])
    pairwise_stats[[key]] <- rolling_stats(
      x=mid_by_sym[[SYMS[i]]]$mid[1:10],
      y=mid_by_sym[[SYMS[j]]]$mid[1:10],
      wlen=WINDOW_LEN
    )
    break
  }
  break
}
```



At each point in time, we compute the SVD of the covariance matrix. We compute a forecast price $P_*$, the projection of the actual price $P$ onto the first principal component of the covariance matrix.



















